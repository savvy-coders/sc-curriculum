# Async and APIs
## Working with Time
One of the hallmarks of an interactive application is that we, as developers, have a fluid interaction with time. Events can happen at any time, in any order, and it's up to us to "listen" to and "handle" any event _whenever_ they end up happening. Our SPA renders our app, waits/listens for a user event, then renders our app again based on the event, and so on...

Up to this point, though, we've been operating under the assumption that the only "delays" that might occur came from _users_, rather than from within _our own application processes_. But what happens when we aren't sure how long it'll take for our code to execute?

> **NOTE**: Remember, `setTimeout()` takes two arguments, a callback function that is executed after the timeout/delay, and a delay (in milliseconds): `setTimeout(() => {}, delay)`

Think about the following:
```javascript
function randomFinish(label) {
  const randomTime = Math.random() * 1000;

  setTimeout(() => console.log(label + "is done!"), randomTime);
}

randomFinish("function 1");
randomFinish("function 2");
randomFinish("function 3");
```

There's no guarantee that the `function`s would finish in order! The functions are not _synchronized_/ordered in time. They are _asynchronous_. When `function 1` sets a delay with `setTimeout`, JS does not wait around for that pause to finish before executing more lines of code/functions.

### **Activity 1: asynchronous functions example**
1. In your terminal, navigate to `8.3-Activities` in the curriculum
2. Using `node`, run `randomFinish.js` in your terminal - `node randomFinish.js` 
3. Run `randomFinish.js` a few more times. Notice that each time we run the file, the functions finish in a random order.

How could we handle a situation where we **always** wanted `function 1` to fire before `function 2`, before `function 3`, even when we don't know how long it will take for each function to finish?

---
## Promises
One way we can control the flow of asynchronous functions is with the `Promise` constructor Object/class. 

Promises are like IOUs: you can create an IOU, specify how you'd like to handle whatever comes back from the IOU, and then the IOU can resolve in some way later on (either, "here's what you're owed" or "sorry, you get nothing").

A `Promise` is created with the `new` keyword, and is given a callback function that is passed two parameters: a `resolve` function and a `reject` function, which handle the two possible outcomes of a `Promise`. These two options can then be handled using the `.then` or `.catch` methods of the newly-constructed Promise.

That's a lot to take in, so let's see what our example above might look like with Promises:

```javascript
function handleFinish(count, resolve) {
  const label = `function ${count}`;

  console.log(`${label} is done!`);

  resolve(count + 1);
  // resolves the Promise that was constructed in randomFinish,
  // to be handled with .then()
}

function randomFinish(count) {
  const randomTime = Math.random() * 1000;

  return new Promise(resolve => { // the Promise constructor takes one argument: the function below
    // resolve is a function, too! reject is unused in this example
    setTimeout(() => handleFinish(count, resolve), randomTime);
  });
}

randomFinish(1)
  .then(randomFinish)
  .then(randomFinish);
```
Wow! Check out that final syntax... by returning `Promises`, each iteration of `randomFinish` can be chained together using the `.then` method. Not only is that clear and easy to read, but the important functions are all grouped together to make the whole application's flow easier to understand.

_However_, as we can see, constructing our own Promises is fairly complicated and difficult to read. Surely, there is an easier way to handle asynchronous JS... (there are at least two!)

### **Activity 2: promises example**
1. In your terminal, while still in `8.3-Activities`, use `node` to run `promises.js`
2. Run `promises.js` a few more times, notice that it always runs "in order".

---
## AJAX
So this is neat, but when do we use this "in the real world"? Sure, there are some UI interactions that might require a `setTimeout`-driven delay, but those are rare. Instead, the `Promise` _structure_ and _syntax_ are used primarily for those functions that are meant to **fetch data asynchronously**. 

**A**synchronous **J**avaScript **A**nd **X**ML (**AJAX**) is how most JS applications interact with _data_: pulling information that can be handled by JavaScript from an **A**pplication **P**rogramming **I**nterface (**API**).

---
## RESTful JSON APIs
The most common type of API you'll interact with as a web developer is a **RESTful** (**Re**sponsive **S**tate **T**ransfer) **JSON API**. This kind of API leverages the HTTP verbs that we've seen before in our work with forms \(e.g. `GET`, `POST`, etc.\), but uses a JavaScript-compatible data format instead of URL-encoded data. To make more sense of this idea, let's take a look at an example API that's set up for us to make AJAX requests.

### **Activity 3: examine a RESTful API in the browser**
1. Navigate to [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/) and take a look at the documentation on that page.
2. Now to go [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts). What comes back?
3. Instead of returning HTML, this URL returns plain text formatted according to JavaScript standards. This kind of URL is called a "route" or an "endpoint", and it's returning data in JSON \("JavaScript Object Notation"\) format. What are the data types you see here?
4. What happens when you go to [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1) or [https://jsonplaceholder.typicode.com/posts/2](https://jsonplaceholder.typicode.com/posts/2)? The number at the end represents the `id` of the post returned. What are some benefits to constructing routes this way?

---
## `fetch`
If we're going to use data from an API like this one, we have to accept that there are going to be some _delays_ and _uncertainties_ regarding the acquisition of this data. There will be:
* time spent sending the request
* time spent retrieving the information
* time spent parsing the information
* possibility of failure throughout the entire operation.

Luckily, most **browsers** have implemented at least a part of the new [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) for retrieving data asynchronously using Promises. Let's try it out with JSON placeholder!

> **NOTE**: When we `fetch` data from an API, we must first "unwrap" or parse the initial response into JSON. With the data formatted correctly, we can then use the JSON response as a JS Object.
> ```javascript
> // fetching our data from an API
> fetch("url-to-API-endpoint")
>   // parsing our response into JSON format
>   .then(response => response.json())
>   // "using" the formatted response in our script
>   .then(json => console.log(json));
> ```

### **Activity 4: `fetch`ing data from an API**
1. From `8.3-Activities`, try running `fetchAPI.js` with `node`. We get a reference error that says `fetch` is not defined. We get this error because `fetch` only works _in the browser_
2. Instead, still in `8.3-Activities`, locally serve the `index.html` file with `live-server .`
3. Notice that `index.js` is linked to the same `fetchAPI.js` we ran with `node`.
4. Open the console to examine the results of our API request. Our data is output as a fully-parsed (ready-to-use) JS Object

`fetch` works quite well for very basic `GET` requests, but it can be tough to work with for more complex AJAX operations. There are also slight deviations between browser implementations, which can lead to some frustrating and hard-to-track-down bugs in the future. Luckily, we have third-party libraries to help us out!

---
## `axios`
The library that we'll use for the remainder of the course is called [axios](https://github.com/axios/axios). It's like `fetch`, but works in _and_ out of the browser, has a number of more sensible defaults that are missing from `fetch`, and is just a bit more convenient for complex requests. Let's try using `axios` to fetch some blog posts for our `Blog` page!

`axios` is a third-party library, so we'll need to include it as a dependency through `npm`:
```
npm install --save axios
```

Let's re-write our `fetch` API request from the previous activity with `axios`. You'll notice that it looks pretty similar, but doesn't require `fetch`'s unwrapping/JSON parsing step:

   ```javascript
   axios
     .get("https://jsonplaceholder.typicode.com/posts")
     .then(response => console.log(response.data));
   ```
### **Activity 5: fetching data with `axios` for our SPA**
We're going to be building a new "Blog" page/view using the JSON placeholder API we have been using.
1. Let's start by creating a new piece of state: Blog. In `store`, create a new file - `Blog.js`
2. Inside `store/Blog.js`, export an object with `header`, `view`, and `posts` keys.
    ```javascript
    // in store/Blog.js
    export default {
      header: "My Blog",
      view: "Blog",
      posts: []
    };
    ```
3. Don't forget to import/export `Blog` from `store/index.js`! If we don't, we won't have access to our new Blog piece of state.
    ```javascript
    export { default as Blog } from "./Blog";
    ```
4. In our "root" `index.js`, import `axios` from our node modules (like we imported `navigo` or `lodash`)
    ```javascript
    import axios from "axios";
    ```
5. After importing axios, we will use it to get our blog data and save each of the posts in in state. 
    ```javascript
    // get data from an API endpoint
    axios.get("https://jsonplaceholder.typicode.com/posts")
      // handle the response from the API
      .then(response => {
        // for each post in the response Array,
        response.data.forEach(post => {
          // add it to state.Blog.posts
          state.Blog.posts.push(post);
        });
      })
    ```
6. Now we have all of our blog post data stored in state, but we don't currently have a Blog view to display the information. We need the `views/Blog.js` functional component. Let's start by creating a `Blog.js` file inside our `views` folder.
7. Inside our `views/Blog.js`, we need to export by default a function that takes in a piece of state and returns a template literal of HTML.
    ```javascript
    export default st => `
    <section id="blog">
    </section>`
    ```
8. Now we need to construct or blog post HTML inside our `<section>` tag. We want to `map` over our blog posts, format them as HTML inside a template literal, then `join` all the posts into a single string.
    ```javascript
    // inside the blank line, we format each post into HTML
    export default st => `
    <section id="blog">
    ${st.posts.map(post => {
      
    }).join()}
    </section>`
    ```
9. Our HTML for each blog post might be fairly complex. We _could_ do all the complex formatting inside our template literal, but a better solution is to create a function that formats a single post. Then we can simply use that function inside our template literal, creating much cleaner code.
    ```javascript
    function formatBlogPost(post) {
      return `
      <div class="blog-post">
        <h4>${post.title} by User ${post.userId}</h4>
        <p>${post.body}</p>
      </div>`
    }
    ```
    ```javascript
    export default st => `
    <section id="blog">
    ${st.posts.map(post => {
      formatBlogPost(post)
    }).join()}
    </section>`
    ```
10. Don't forget to import/export `Blog` from our `views/index.js` aggregator!
    ```javascript
    export { default as Blog } from "./Blog"
    ```
11. Next, we need to add "Blog" to the exported Array from `store/Links.js` so that our Blog page appears in our nav bar.
12. Our page is _pretty good_ right now. If we start on our Home page (or page but Blog), and then visit our Blog page, everything looks fine. But what if we started on our Blog page? 

    Our script needs some time to load and save our blog posts from the API. If the first page we rendered was our Blog page, our posts won't render since the data is not saved in state yet. 
    
    And even though our posts are saved in state almost immediately after the page loads, we have to navigate away from Blog and back to Blog in order for our Blog view to render correctly.

    We can combine the powers of `axios` with our navigo `router` to re-render the current page after we receive our data, solving this problem.
    ```javascript
    axios.get("https://jsonplaceholder.typicode.com/posts")
      .then(response => {
        response.data.forEach(post => {
          state.Blog.posts.push(post);
        });
        // use our router Object to find the "current page"/last resolved route
        const params = router.lastRouteResolved().params;
        // this params key "page" is the same as our "variable" we specified in our router's on() method
        render(state[params.page]);
      })
    ```
13. Our SPA is looking great, but there is one more slight improvement we can make. As our code is currently written, if we started on our Home page and our API data loads, we will get an error in our browser's console
    ```
    TypeError: Cannot read property 'page' of undefined
    ``` 
    Since our Home route is simply "/", our router does not create any params and our `params` variable is `undefined`. 

    We can wrap our render function in an if statement that catches this error.
    ```javascript
    axios.get("https://jsonplaceholder.typicode.com/posts")
      .then(response => {
        response.data.forEach(post => {
          state.Blog.posts.push(post);
        });
        const params = router.lastRouteResolved().params;
        // if params exists (any page but Home),
        if (params) {
          // re-render the page
          render(state[params.page]);
        }
      })
    ```
